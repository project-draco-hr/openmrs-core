{
  log.debug("Merging patients: (preferred)" + preferred.getPatientId() + ", (notPreferred) "+ notPreferred.getPatientId());
  if (preferred.getPatientId().equals(notPreferred.getPatientId())) {
    log.debug("Merge operation cancelled: Cannot merge user" + preferred.getPatientId() + " to self");
    throw new APIException("Merge operation cancelled: Cannot merge user " + preferred.getPatientId() + " to self");
  }
  PersonMergeLogData mergedData=new PersonMergeLogData();
  EncounterService es=Context.getEncounterService();
  for (  Encounter e : es.getEncountersByPatient(notPreferred)) {
    e.setPatient(preferred);
    log.debug("Merging encounter " + e.getEncounterId() + " to "+ preferred.getPatientId());
    Encounter persisted=es.saveEncounter(e);
    mergedData.addMovedEncounter(persisted.getUuid());
  }
  ProgramWorkflowService programService=Context.getProgramWorkflowService();
  for (  PatientProgram pp : programService.getPatientPrograms(notPreferred,null,null,null,null,null,false)) {
    if (!pp.getVoided()) {
      PatientProgram enroll=pp.copy();
      enroll.setPatient(preferred);
      log.debug("Copying patientProgram " + pp.getPatientProgramId() + " to "+ preferred.getPatientId());
      PatientProgram persisted=programService.savePatientProgram(enroll);
      mergedData.addCreatedProgram(persisted.getUuid());
    }
  }
  PersonService personService=Context.getPersonService();
  Set<String> existingRelationships=new HashSet<String>();
  for (  Relationship rel : personService.getRelationshipsByPerson(preferred)) {
    existingRelationships.add(relationshipHash(rel,preferred));
  }
  for (  Relationship rel : personService.getRelationshipsByPerson(notPreferred)) {
    if (!rel.isVoided()) {
      boolean personAisPreferred=rel.getPersonA().equals(preferred);
      boolean personAisNotPreferred=rel.getPersonA().equals(notPreferred);
      boolean personBisPreferred=rel.getPersonB().equals(preferred);
      boolean personBisNotPreferred=rel.getPersonB().equals(notPreferred);
      String relHash=relationshipHash(rel,notPreferred);
      if ((personAisPreferred && personBisNotPreferred) || (personBisPreferred && personAisNotPreferred)) {
        personService.voidRelationship(rel,"person " + (personAisNotPreferred ? "A" : "B") + " was merged to person "+ (personAisPreferred ? "A" : "B"));
      }
 else       if (existingRelationships.contains(relHash)) {
        personService.voidRelationship(rel,"person " + (personAisNotPreferred ? "A" : "B") + " was merged and a relationship already exists");
      }
 else {
        Relationship tmpRel=rel.copy();
        if (personAisNotPreferred)         tmpRel.setPersonA(preferred);
        if (personBisNotPreferred)         tmpRel.setPersonB(preferred);
        log.debug("Copying relationship " + rel.getRelationshipId() + " to "+ preferred.getPatientId());
        Relationship persisted=personService.saveRelationship(tmpRel);
        mergedData.addCreatedRelationship(persisted.getUuid());
        personService.voidRelationship(rel,"person " + (personAisNotPreferred ? "A" : "B") + " was merged, relationship copied to #"+ tmpRel.getRelationshipId());
        existingRelationships.add(relHash);
      }
      mergedData.addVoidedRelationship(rel.getUuid());
    }
  }
  ObsService obsService=Context.getObsService();
  for (  Obs obs : obsService.getObservationsByPerson(notPreferred)) {
    if (obs.getEncounter() == null && !obs.isVoided()) {
      obs.setPerson(preferred);
      Obs persisted=obsService.saveObs(obs,"Merged from patient #" + notPreferred.getPatientId());
      mergedData.addMovedIndependentObservation(persisted.getUuid());
    }
  }
  OrderService os=Context.getOrderService();
  for (  Order o : os.getOrdersByPatient(notPreferred)) {
    if (o.getEncounter() == null && !o.getVoided()) {
      Order tmpOrder=o.copy();
      tmpOrder.setPatient(preferred);
      Order persisted=os.saveOrder(tmpOrder);
      mergedData.addCreatedOrder(persisted.getUuid());
    }
  }
  for (  PatientIdentifier pi : notPreferred.getActiveIdentifiers()) {
    PatientIdentifier tmpIdentifier=new PatientIdentifier();
    tmpIdentifier.setIdentifier(pi.getIdentifier());
    tmpIdentifier.setIdentifierType(null);
    tmpIdentifier.setLocation(pi.getLocation());
    tmpIdentifier.setPatient(preferred);
    boolean found=false;
    for (    PatientIdentifier preferredIdentifier : preferred.getIdentifiers()) {
      if (preferredIdentifier.getIdentifier() != null && preferredIdentifier.getIdentifier().equals(tmpIdentifier.getIdentifier()) && preferredIdentifier.getIdentifierType() != null && preferredIdentifier.getIdentifierType().equals(tmpIdentifier.getIdentifierType()))       found=true;
    }
    if (!found) {
      tmpIdentifier.setIdentifierType(pi.getIdentifierType());
      tmpIdentifier.setCreator(Context.getAuthenticatedUser());
      tmpIdentifier.setDateCreated(new Date());
      tmpIdentifier.setVoided(false);
      tmpIdentifier.setVoidedBy(null);
      tmpIdentifier.setVoidReason(null);
      tmpIdentifier.setUuid(UUID.randomUUID().toString());
      tmpIdentifier.setPreferred(false);
      preferred.addIdentifier(tmpIdentifier);
      mergedData.addCreatedIdentifier(tmpIdentifier.getUuid());
      log.debug("Merging identifier " + tmpIdentifier.getIdentifier() + " to "+ preferred.getPatientId());
    }
  }
  for (  PersonName newName : notPreferred.getNames()) {
    boolean containsName=false;
    for (    PersonName currentName : preferred.getNames()) {
      String given=newName.getGivenName();
      String middle=newName.getMiddleName();
      String family=newName.getFamilyName();
      if ((given != null && given.equals(currentName.getGivenName())) && (middle != null && middle.equals(currentName.getMiddleName())) && (family != null && family.equals(currentName.getFamilyName()))) {
        containsName=true;
      }
    }
    if (!containsName) {
      PersonName tmpName=PersonName.newInstance(newName);
      tmpName.setPersonNameId(null);
      tmpName.setVoided(false);
      tmpName.setVoidedBy(null);
      tmpName.setVoidReason(null);
      tmpName.setPreferred(false);
      tmpName.setUuid(UUID.randomUUID().toString());
      preferred.addName(tmpName);
      mergedData.addCreatedName(tmpName.getUuid());
      log.debug("Merging name " + newName.getGivenName() + " to "+ preferred.getPatientId());
    }
  }
  for (  PersonAddress newAddress : notPreferred.getAddresses()) {
    boolean containsAddress=false;
    for (    PersonAddress currentAddress : preferred.getAddresses()) {
      String address1=currentAddress.getAddress1();
      String address2=currentAddress.getAddress2();
      String cityVillage=currentAddress.getCityVillage();
      if ((address1 != null && address1.equals(newAddress.getAddress1())) && (address2 != null && address2.equals(newAddress.getAddress2())) && (cityVillage != null && cityVillage.equals(newAddress.getCityVillage()))) {
        containsAddress=true;
      }
    }
    if (!containsAddress) {
      PersonAddress tmpAddress=(PersonAddress)newAddress.clone();
      tmpAddress.setPersonAddressId(null);
      tmpAddress.setVoided(false);
      tmpAddress.setVoidedBy(null);
      tmpAddress.setVoidReason(null);
      tmpAddress.setUuid(UUID.randomUUID().toString());
      preferred.addAddress(tmpAddress);
      mergedData.addCreatedAddress(tmpAddress.getUuid());
      log.debug("Merging address " + newAddress.getPersonAddressId() + " to "+ preferred.getPatientId());
    }
  }
  for (  PersonAttribute attr : notPreferred.getAttributes()) {
    if (!attr.isVoided()) {
      PersonAttribute tmpAttr=attr.copy();
      tmpAttr.setPerson(null);
      tmpAttr.setUuid(UUID.randomUUID().toString());
      preferred.addAttribute(tmpAttr);
      mergedData.addCreatedAttribute(tmpAttr.getUuid());
    }
  }
  mergedData.setPriorGender(preferred.getGender());
  if (!"M".equals(preferred.getGender()) && !"F".equals(preferred.getGender()))   preferred.setGender(notPreferred.getGender());
  mergedData.setPriorDateOfBirth(preferred.getBirthdate());
  mergedData.setPriorDateOfBirthEstimated(preferred.isBirthdateEstimated());
  if (preferred.getBirthdate() == null || preferred.getBirthdate().equals("") || (preferred.getBirthdateEstimated() && !notPreferred.getBirthdateEstimated())) {
    preferred.setBirthdate(notPreferred.getBirthdate());
    preferred.setBirthdateEstimated(notPreferred.getBirthdateEstimated());
  }
  mergedData.setPriorDateOfDeath(preferred.getDeathDate());
  if (preferred.getDeathDate() == null || preferred.getDeathDate().equals(""))   preferred.setDeathDate(notPreferred.getDeathDate());
  if (preferred.getCauseOfDeath() != null)   mergedData.setPriorCauseOfDeath(preferred.getCauseOfDeath().getUuid());
  if (preferred.getCauseOfDeath() == null || preferred.getCauseOfDeath().equals(""))   preferred.setCauseOfDeath(notPreferred.getCauseOfDeath());
  Context.getPatientService().voidPatient(notPreferred,"Merged with patient #" + preferred.getPatientId());
  personService.voidPerson(notPreferred,"The patient corresponding to this person has been voided and Merged with patient #" + preferred.getPatientId());
  changeUserAssociations(preferred,notPreferred,mergedData);
  savePatient(preferred);
  PersonMergeLog personMergeLog=new PersonMergeLog();
  personMergeLog.setWinner(preferred);
  personMergeLog.setLoser(notPreferred);
  personMergeLog.setPersonMergeLogData(mergedData);
  Context.getPersonService().savePersonMergeLog(personMergeLog);
}
