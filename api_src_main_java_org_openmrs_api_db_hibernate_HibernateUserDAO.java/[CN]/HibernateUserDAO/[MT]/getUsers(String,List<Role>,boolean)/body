{
  log.debug("name: " + name);
  name=HibernateUtil.escapeSqlWildcards(name,sessionFactory);
  List<String> criteria=new ArrayList<String>();
  int counter=0;
  Map<String,String> namesMap=new HashMap<String,String>();
  if (name != null) {
    name=name.replace(", "," ");
    String[] names=name.split(" ");
    for (    String n : names) {
      if (n != null && n.length() > 0) {
        String key="name" + ++counter;
        String value=n + "%";
        namesMap.put(key,value);
        criteria.add("(user.username like :" + key + " or user.systemId like :"+ key+ " or name.givenName like :"+ key+ " or name.middleName like :"+ key+ " or name.familyName like :"+ key+ " or name.familyName2 like :"+ key+ ")");
      }
    }
  }
  if (includeRetired == false)   criteria.add("user.retired = false");
  String hql="select distinct user from User as user inner join user.person.names as name ";
  if (criteria.size() > 0)   hql+="where ";
  for (Iterator<String> i=criteria.iterator(); i.hasNext(); ) {
    hql+=i.next() + " ";
    if (i.hasNext())     hql+="and ";
  }
  hql+=" order by user.username asc";
  Query query=sessionFactory.getCurrentSession().createQuery(hql);
  for (  Map.Entry<String,String> e : namesMap.entrySet())   query.setString(e.getKey(),e.getValue());
  List<User> returnList;
  if (roles != null && roles.size() > 0) {
    returnList=new Vector();
    log.debug("looping through to find matching roles");
    for (    Object o : query.list()) {
      User u=(User)o;
      for (      Role r : roles)       if (u.hasRole(r.getRole(),true)) {
        returnList.add(u);
        break;
      }
    }
  }
 else {
    log.debug("not looping because there appears to be no roles");
    returnList=query.list();
  }
  if (!CollectionUtils.isEmpty(returnList))   Collections.sort(returnList,new UserByNameComparator());
  return returnList;
}
