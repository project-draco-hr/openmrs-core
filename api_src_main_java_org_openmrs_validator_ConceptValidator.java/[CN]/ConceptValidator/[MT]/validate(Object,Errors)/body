{
  if (obj == null || !(obj instanceof Concept))   throw new IllegalArgumentException("The parameter obj should not be null and must be of type" + Concept.class);
  Concept conceptToValidate=(Concept)obj;
  if (conceptToValidate.getNames().size() == 0) {
    errors.reject("Concept.name.atLeastOneRequired");
    return;
  }
  boolean hasFullySpecifiedName=false;
  for (  Locale conceptNameLocale : conceptToValidate.getAllConceptNameLocales()) {
    boolean fullySpecifiedNameForLocaleFound=false;
    boolean preferredNameForLocaleFound=false;
    boolean shortNameForLocaleFound=false;
    Set<String> validNamesFoundInLocale=new HashSet<String>();
    Collection<ConceptName> namesInLocale=conceptToValidate.getNames(conceptNameLocale);
    for (    ConceptName nameInLocale : namesInLocale) {
      if (StringUtils.isBlank(nameInLocale.getName())) {
        log.debug("Name in locale '" + conceptNameLocale.toString() + "' cannot be an empty string or white space");
        errors.reject("Concept.name.empty");
      }
      if (nameInLocale.isLocalePreferred() != null) {
        if (nameInLocale.isLocalePreferred() && !preferredNameForLocaleFound) {
          if (nameInLocale.isIndexTerm()) {
            log.warn("Preferred name in locale '" + conceptNameLocale.toString() + "' shouldn't be an index term");
            errors.reject("Concept.error.preferredName.is.indexTerm");
          }
 else           if (nameInLocale.isShort()) {
            log.warn("Preferred name in locale '" + conceptNameLocale.toString() + "' shouldn't be a short name");
            errors.reject("Concept.error.preferredName.is.shortName");
          }
 else           if (nameInLocale.isVoided()) {
            log.warn("Preferred name in locale '" + conceptNameLocale.toString() + "' shouldn't be a voided name");
            errors.reject("Concept.error.preferredName.is.voided");
          }
          preferredNameForLocaleFound=true;
        }
 else         if (nameInLocale.isLocalePreferred() && preferredNameForLocaleFound) {
          log.warn("Found multiple preferred names in locale '" + conceptNameLocale.toString() + "'");
          errors.reject("Concept.error.multipleLocalePreferredNames");
        }
      }
      if (nameInLocale.isFullySpecifiedName()) {
        if (!hasFullySpecifiedName)         hasFullySpecifiedName=true;
        if (!fullySpecifiedNameForLocaleFound)         fullySpecifiedNameForLocaleFound=true;
 else {
          log.warn("Found multiple fully specified names in locale '" + conceptNameLocale.toString() + "'");
          errors.reject("Concept.error.multipleFullySpecifiedNames");
        }
        if (nameInLocale.isVoided()) {
          log.warn("Fully Specified name in locale '" + conceptNameLocale.toString() + "' shouldn't be a voided name");
          errors.reject("Concept.error.fullySpecifiedName.is.voided");
        }
      }
      if (nameInLocale.isShort()) {
        if (!shortNameForLocaleFound)         shortNameForLocaleFound=true;
 else {
          log.warn("Found multiple short names in locale '" + conceptNameLocale.toString() + "'");
          errors.reject("Concept.error.multipleShortNames");
        }
      }
      if (nameInLocale.isLocalePreferred() || nameInLocale.isFullySpecifiedName()) {
        List<Concept> conceptsWithPossibleDuplicateNames=Context.getConceptService().getConceptsByName(nameInLocale.getName());
        if (conceptsWithPossibleDuplicateNames.size() > 0) {
          for (          Concept concept : conceptsWithPossibleDuplicateNames) {
            if (concept.isRetired() || (conceptToValidate.getConceptId() != null && conceptToValidate.getConceptId().equals(concept.getConceptId())))             continue;
            if ((concept.getFullySpecifiedName(conceptNameLocale) != null && concept.getFullySpecifiedName(conceptNameLocale).getName().equalsIgnoreCase(nameInLocale.getName())) || (concept.getPreferredName(conceptNameLocale) != null && concept.getPreferredName(conceptNameLocale).getName().equalsIgnoreCase(nameInLocale.getName()))) {
              throw new DuplicateConceptNameException("'" + nameInLocale.getName() + "' is a duplicate name in locale '"+ conceptNameLocale.toString()+ "'");
            }
          }
        }
      }
      if (errors.hasErrors()) {
        log.debug("Concept name '" + nameInLocale.getName() + "' for locale '"+ conceptNameLocale+ "' is invalid");
        return;
      }
      if (!nameInLocale.isShort()) {
        if (!validNamesFoundInLocale.add(nameInLocale.getName().toLowerCase()))         throw new DuplicateConceptNameException("'" + nameInLocale.getName() + "' is a duplicate name in locale '"+ conceptNameLocale.toString()+ "' for the same concept");
      }
      if (log.isDebugEnabled())       log.debug("Valid name found: " + nameInLocale.getName());
    }
  }
  if (!hasFullySpecifiedName) {
    log.debug("Concept has no fully specified name");
    errors.reject("Concept.error.no.FullySpecifiedName");
  }
  if (CollectionUtils.isNotEmpty(conceptToValidate.getConceptMappings())) {
    int index=0;
    Set<Integer> mappedTermIds=null;
    for (    ConceptMap map : conceptToValidate.getConceptMappings()) {
      if (map.getConceptReferenceTerm() == null) {
        errors.rejectValue("conceptMappings[" + index + "].conceptReferenceTerm","Concept.map.termRequired","The concept reference term property is required for a concept map");
        return;
      }
 else       if (map.getConceptReferenceTerm().getConceptReferenceTermId() == null) {
        errors.rejectValue("conceptMappings[" + index + "].conceptReferenceTerm","ConceptReferenceTerm.term.notInDatabase","Only existing concept reference terms can be mapped");
        return;
      }
 else       if (map.getConceptMapType() == null) {
        errors.rejectValue("conceptMappings[" + index + "].conceptMapType","Concept.map.typeRequired","The concept map type is required for a concept map");
        return;
      }
 else       if (map.getConceptMapType().getConceptMapTypeId() == null) {
        errors.rejectValue("conceptMappings[" + index + "].conceptMapType","ConceptReferenceTerm.mapType.notInDatabase","Only existing concept map types can be used");
        return;
      }
      if (errors.hasErrors())       return;
      if (mappedTermIds == null)       mappedTermIds=new HashSet<Integer>();
      if (!mappedTermIds.add(map.getConceptReferenceTerm().getId())) {
        errors.rejectValue("conceptMappings[" + index + "]","ConceptReferenceTerm.term.alreadyMapped","Cannot map a reference term multiple times to the same concept");
      }
      index++;
    }
  }
}
