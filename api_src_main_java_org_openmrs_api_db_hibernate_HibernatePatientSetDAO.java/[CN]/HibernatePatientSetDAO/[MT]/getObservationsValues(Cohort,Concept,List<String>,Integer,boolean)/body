{
  Map<Integer,List<List<Object>>> ret=new HashMap<Integer,List<List<Object>>>();
  List<String> aliases=new Vector<String>();
  Boolean conditional=false;
  Criteria criteria=sessionFactory.getCurrentSession().createCriteria("org.openmrs.Obs","obs");
  criteria.setCacheMode(CacheMode.IGNORE);
  List<String> columns=new Vector<String>();
  for (  String attribute : attributes) {
    List<String> classNames=new Vector<String>();
    if (attribute == null) {
      columns=findObsValueColumnName(c);
      if (columns.size() > 1)       conditional=true;
      continue;
    }
 else     if (attribute.equals("valueDatetime")) {
    }
 else     if (attribute.equals("obsDatetime")) {
    }
 else     if (attribute.equals("location")) {
      classNames.add("obs.location");
      attribute="location.name";
    }
 else     if (attribute.equals("comment")) {
    }
 else     if (attribute.equals("encounterType")) {
      classNames.add("obs.encounter");
      classNames.add("encounter.encounterType");
      attribute="encounterType.name";
    }
 else     if (attribute.equals("provider")) {
      classNames.add("obs.encounter");
      attribute="encounter.provider";
    }
 else {
      throw new DAOException("Attribute: " + attribute + " is not recognized. Please add reference in "+ this.getClass());
    }
    for (    String className : classNames) {
      if (!aliases.contains(className)) {
        criteria.createAlias(className,className.split("\\.")[1]);
        aliases.add(className);
      }
    }
    columns.add(attribute);
  }
  String aliasName="obs";
  ProjectionList projections=Projections.projectionList();
  projections.add(Projections.property("obs.personId"));
  for (  String col : columns) {
    if (col.contains("."))     projections.add(Projections.property(col));
 else     projections.add(Projections.property(aliasName + "." + col));
  }
  criteria.setProjection(projections);
  if (patients != null)   criteria.add(Restrictions.in("obs.personId",patients.getMemberIds()));
  criteria.add(Expression.eq("obs.concept",c));
  criteria.add(Expression.eq("obs.voided",false));
  if (showMostRecentFirst)   criteria.addOrder(org.hibernate.criterion.Order.desc("obs.obsDatetime"));
 else   criteria.addOrder(org.hibernate.criterion.Order.asc("obs.obsDatetime"));
  long start=System.currentTimeMillis();
  List<Object[]> rows=criteria.list();
  log.debug("Took: " + (System.currentTimeMillis() - start) + " ms to run the patient/obs query");
  for (  Object[] rowArray : rows) {
    Integer ptId=(Integer)rowArray[0];
    List<List<Object>> oldArr=ret.get(ptId);
    if (limit != null && limit > 0 && oldArr != null && oldArr.size() >= limit) {
    }
 else {
      Boolean tmpConditional=conditional.booleanValue();
      int index=1;
      List<Object> row=new Vector<Object>();
      while (index < rowArray.length) {
        Object value=rowArray[index++];
        if (tmpConditional) {
          if (index == 2 && value != null)           row.add(value);
 else           row.add(rowArray[index]);
          tmpConditional=false;
          index++;
        }
 else         row.add(value == null ? "" : value);
      }
      if (oldArr == null) {
        List<List<Object>> arr=new Vector<List<Object>>();
        arr.add(row);
        ret.put(ptId,arr);
      }
 else {
        oldArr.add(row);
        ret.put(ptId,oldArr);
      }
    }
  }
  return ret;
}
