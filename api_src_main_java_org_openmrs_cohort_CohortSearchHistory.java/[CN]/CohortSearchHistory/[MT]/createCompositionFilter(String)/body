{
  Set<String> andWords=new HashSet<String>();
  Set<String> orWords=new HashSet<String>();
  Set<String> notWords=new HashSet<String>();
  andWords.add("and");
  andWords.add("intersection");
  andWords.add("*");
  orWords.add("or");
  orWords.add("union");
  orWords.add("+");
  notWords.add("not");
  notWords.add("!");
  List<Object> currentLine=new ArrayList<Object>();
  try {
    StreamTokenizer st=new StreamTokenizer(new StringReader(description));
    st.ordinaryChar('(');
    st.ordinaryChar(')');
    Stack<List<Object>> stack=new Stack<List<Object>>();
    while (st.nextToken() != StreamTokenizer.TT_EOF) {
      if (st.ttype == StreamTokenizer.TT_NUMBER) {
        Integer thisInt=new Integer((int)st.nval);
        if (thisInt < 1 || thisInt > searchHistory.size()) {
          log.error("number < 1 or > search history size");
          return null;
        }
        currentLine.add(thisInt);
      }
 else       if (st.ttype == '(') {
        stack.push(currentLine);
        currentLine=new ArrayList<Object>();
      }
 else       if (st.ttype == ')') {
        List<Object> l=stack.pop();
        l.add(currentLine);
        currentLine=l;
      }
 else       if (st.ttype == StreamTokenizer.TT_WORD) {
        String str=st.sval.toLowerCase();
        if (andWords.contains(str))         currentLine.add(PatientSetService.BooleanOperator.AND);
 else         if (orWords.contains(str))         currentLine.add(PatientSetService.BooleanOperator.OR);
 else         if (notWords.contains(str))         currentLine.add(PatientSetService.BooleanOperator.NOT);
 else         throw new IllegalArgumentException("Don't recognize " + st.sval);
      }
    }
  }
 catch (  Exception ex) {
    log.error("Error in description string: " + description,ex);
    return null;
  }
  if (!testCompositionList(currentLine)) {
    log.error("Description string failed test: " + description);
    return null;
  }
  PatientSearch ret=new PatientSearch();
  ret.setParsedComposition(currentLine);
  return ret;
}
