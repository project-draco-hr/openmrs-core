{
  Locale loc=Context.getLocale();
  DateFormat df=Context.getDateFormat();
  List<Concept> conceptList=new ArrayList<Concept>();
  Set<Integer> conceptIds=new HashSet<Integer>();
  ConceptService cs=Context.getConceptService();
  for (StringTokenizer st=new StringTokenizer(concepts,"|"); st.hasMoreTokens(); ) {
    String s=st.nextToken().trim();
    log.debug("looking at " + s);
    boolean isSet=s.startsWith("set:");
    if (isSet)     s=s.substring(4).trim();
    Concept c=null;
    if (s.startsWith("name:")) {
      String name=s.substring(5).trim();
      c=cs.getConceptByName(name);
    }
 else {
      try {
        c=cs.getConcept(Integer.valueOf(s.trim()));
      }
 catch (      Exception ex) {
      }
    }
    if (c != null) {
      if (isSet) {
        List<Concept> inSet=cs.getConceptsByConceptSet(c);
        for (        Concept con : inSet) {
          if (!conceptIds.contains(con.getConceptId())) {
            conceptList.add(con);
            conceptIds.add(con.getConceptId());
          }
        }
      }
 else {
        if (!conceptIds.contains(c.getConceptId())) {
          conceptList.add(c);
          conceptIds.add(c.getConceptId());
        }
      }
    }
    log.debug("conceptList == " + conceptList);
  }
  Set<Integer> conceptsWithObs=new HashSet<Integer>();
  SortedSet<Date> dates=new TreeSet<Date>();
  Map<String,List<Obs>> groupedObs=new HashMap<String,List<Obs>>();
  for (  Obs o : observations) {
    Integer conceptId=o.getConcept().getConceptId();
    if (conceptIds.contains(conceptId)) {
      Date thisDate=o.getObsDatetime();
      if ((fromDate != null && thisDate.compareTo(fromDate) < 0) || (toDate != null && thisDate.compareTo(toDate) > 0)) {
        continue;
      }
      dates.add(thisDate);
      String key=conceptId + "." + thisDate;
      List<Obs> group=groupedObs.get(key);
      if (group == null) {
        group=new ArrayList<Obs>();
        groupedObs.put(key,group);
      }
      group.add(o);
      conceptsWithObs.add(conceptId);
    }
  }
  if (!showEmptyConcepts) {
    for (Iterator<Concept> i=conceptList.iterator(); i.hasNext(); ) {
      if (!conceptsWithObs.contains(i.next().getConceptId()))       i.remove();
    }
  }
  List<Date> dateOrder=new ArrayList<Date>(dates);
  if (sortDescending)   Collections.reverse(dateOrder);
  if (limit > 0 && limit < dateOrder.size()) {
    if (!sortDescending) {
      dateOrder=dateOrder.subList(dateOrder.size() - limit,dateOrder.size());
    }
 else {
      dateOrder=dateOrder.subList(0,limit);
    }
  }
  StringBuilder ret=new StringBuilder();
  ret.append("<table");
  if (id != null)   ret.append(" id=\"" + id + "\"");
  if (cssClass != null)   ret.append(" class=\"" + cssClass + "\"");
  ret.append(">");
  if (orientVertical) {
    if (showConceptHeader) {
      ret.append("<tr>");
      ret.append("<th></th>");
      for (      Concept c : conceptList) {
        ConceptName cn=c.getShortestName(loc,false);
        String name=cn.getName();
        ret.append("<th>");
        if (conceptLink != null) {
          ret.append("<a href=\"" + conceptLink + "conceptId="+ c.getConceptId()+ "\">");
        }
        ret.append(name);
        if (conceptLink != null) {
          ret.append("</a>");
        }
        ret.append("</th>");
      }
      ret.append("</tr>");
    }
    for (    Date date : dateOrder) {
      ret.append("<tr>");
      if (showDateHeader)       ret.append("<th>" + df.format(date) + "</th>");
      for (      Concept c : conceptList) {
        ret.append("<td align=\"center\">");
        String key=c.getConceptId() + "." + date;
        List<Obs> list=groupedObs.get(key);
        if (list != null) {
          if (combineEqualResults) {
            Collection<String> unique=new LinkedHashSet<String>();
            for (            Obs obs : list)             unique.add(obs.getValueAsString(loc));
            for (            String s : unique)             ret.append(s).append("<br/>");
          }
 else {
            for (            Obs obs : list)             ret.append(obs.getValueAsString(loc)).append("<br/>");
          }
        }
        ret.append("</td>");
      }
      ret.append("</tr>");
    }
  }
 else {
    if (showDateHeader) {
      ret.append("<tr>");
      ret.append("<th></th>");
      for (      Date date : dateOrder) {
        ret.append("<th>" + df.format(date) + "</th>");
      }
    }
    for (    Concept c : conceptList) {
      ret.append("<tr>");
      if (showConceptHeader) {
        ConceptName cn=c.getShortestName(loc,false);
        String name=cn.getName();
        ret.append("<th>");
        if (conceptLink != null) {
          ret.append("<a href=\"" + conceptLink + "conceptId="+ c.getConceptId()+ "\">");
        }
        ret.append(name);
        if (conceptLink != null) {
          ret.append("</a>");
        }
        ret.append("</th>");
      }
      for (      Date date : dateOrder) {
        ret.append("<td align=\"center\">");
        String key=c.getConceptId() + "." + date;
        List<Obs> list=groupedObs.get(key);
        if (list != null) {
          if (combineEqualResults) {
            Collection<String> unique=new LinkedHashSet<String>();
            for (            Obs obs : list)             unique.add(obs.getValueAsString(loc));
            for (            String s : unique)             ret.append(s).append("<br/>");
          }
 else {
            for (            Obs obs : list)             ret.append(obs.getValueAsString(loc)).append("<br/>");
          }
        }
        ret.append("</td>");
      }
      ret.append("</tr>");
    }
  }
  ret.append("</table>");
  try {
    JspWriter w=pageContext.getOut();
    w.println(ret);
  }
 catch (  IOException ex) {
    log.error("Error while starting ObsTableWidget tag",ex);
  }
  return SKIP_BODY;
}
