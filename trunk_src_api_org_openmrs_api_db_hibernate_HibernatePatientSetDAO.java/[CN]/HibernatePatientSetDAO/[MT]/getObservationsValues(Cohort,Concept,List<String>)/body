{
  Map<Integer,List<List<Object>>> ret=new HashMap<Integer,List<List<Object>>>();
  List<String> aliases=new Vector<String>();
  Boolean conditional=false;
  Criteria criteria=sessionFactory.getCurrentSession().createCriteria("org.openmrs.Obs","obs");
  criteria.setCacheMode(CacheMode.IGNORE);
  List<String> columns=new Vector<String>();
  for (  String attribute : attributes) {
    List<String> classNames=new Vector<String>();
    if (attribute == null) {
      columns=findObsValueColumnName(c);
      if (columns.size() > 1)       conditional=true;
      continue;
    }
 else     if (attribute.equals("valueDatetime")) {
    }
 else     if (attribute.equals("obsDatetime")) {
    }
 else     if (attribute.equals("location")) {
      classNames.add("obs.location");
      attribute="location.name";
    }
 else     if (attribute.equals("comment")) {
    }
 else     if (attribute.equals("encounterType")) {
      classNames.add("obs.encounter");
      classNames.add("encounter.encounterType");
      attribute="encounterType.name";
    }
 else     if (attribute.equals("provider")) {
      classNames.add("obs.encounter");
      attribute="encounter.provider";
    }
 else {
      throw new DAOException("Attribute: " + attribute + " is not recognized. Please add reference in "+ this.getClass());
    }
    for (    String className : classNames) {
      if (!aliases.contains(className)) {
        criteria.createAlias(className,className.split("\\.")[1]);
        aliases.add(className);
      }
    }
    columns.add(attribute);
  }
  String aliasName="obs";
  ProjectionList projections=Projections.projectionList();
  projections.add(Projections.property("obs.personId"));
  for (  String col : columns) {
    if (col.contains("."))     projections.add(Projections.property(col));
 else     projections.add(Projections.property(aliasName + "." + col));
  }
  criteria.setProjection(projections);
  if (patients != null)   criteria.add(Restrictions.in("obs.personId",patients.getMemberIds()));
  criteria.add(Expression.eq("obs.concept",c));
  criteria.add(Expression.eq("obs.voided",false));
  criteria.addOrder(org.hibernate.criterion.Order.desc("obs.obsDatetime"));
  criteria.addOrder(org.hibernate.criterion.Order.desc("obs.voided"));
  log.debug("criteria: " + criteria);
  List<Object[]> rows=criteria.list();
  for (  Object[] rowArray : rows) {
    Integer ptId=(Integer)rowArray[0];
    Boolean tmpConditional=conditional.booleanValue();
    int index=1;
    List<Object> row=new Vector<Object>();
    while (index < rowArray.length) {
      Object value=rowArray[index++];
      if (tmpConditional) {
        if (index == 2 && value != null)         row.add(value);
 else         row.add(rowArray[index]);
        tmpConditional=false;
        index++;
      }
 else       row.add(value == null ? "" : value);
    }
    if (!ret.containsKey(ptId)) {
      List<List<Object>> arr=new Vector<List<Object>>();
      arr.add(row);
      ret.put(ptId,arr);
    }
 else {
      List<List<Object>> oldArr=ret.get(ptId);
      oldArr.add(row);
      ret.put(ptId,oldArr);
    }
  }
  return ret;
}
