{
  log.debug("Starting with " + phrase);
  for (ListIterator<Object> i=phrase.listIterator(); i.hasNext(); ) {
    Object o=i.next();
    if (o instanceof List)     i.set(toPatientFilter((List<Object>)o));
 else     if (o instanceof Integer)     i.set(getSearchHistory().get((Integer)o - 1));
  }
  log.debug("Base case with " + phrase);
  boolean invertTheNext=false;
  for (ListIterator<Object> i=phrase.listIterator(); i.hasNext(); ) {
    Object o=i.next();
    if (o instanceof BooleanOperator) {
      if ((BooleanOperator)o == BooleanOperator.NOT) {
        i.remove();
        invertTheNext=!invertTheNext;
      }
 else {
        if (invertTheNext)         throw new RuntimeException("Can't have NOT AND. Test() should have failed");
      }
    }
 else {
      if (invertTheNext) {
        i.set(new InversePatientFilter((PatientFilter)o));
        invertTheNext=false;
      }
    }
  }
  log.debug("Finished with NOTs: " + phrase);
  if (phrase.size() == 1) {
    return (PatientFilter)phrase.get(0);
  }
  BooleanOperator bo=BooleanOperator.AND;
  List<PatientFilter> args=new ArrayList<PatientFilter>();
  for (  Object o : phrase)   if (o instanceof BooleanOperator)   bo=(BooleanOperator)o;
 else   args.add((PatientFilter)o);
  return new CompoundPatientFilter(bo,args);
}
