{
  if (search.isSavedSearchReference()) {
    PatientSearch ps=((PatientSearchReportObject)Context.getReportObjectService().getReportObject(search.getSavedSearchId())).getPatientSearch();
    return toPatientFilter(ps,history,evalContext);
  }
 else   if (search.isSavedFilterReference()) {
    return Context.getReportObjectService().getPatientFilterById(search.getSavedFilterId());
  }
 else   if (search.isSavedCohortReference()) {
    Cohort c=Context.getCohortService().getCohort(search.getSavedCohortId());
    if (c != null)     c.getMemberIds().size();
    return new CohortFilter(c);
  }
 else   if (search.isComposition()) {
    if (history == null && search.requiresHistory())     throw new IllegalArgumentException("You can't evaluate this search without a history");
 else     return search.cloneCompositionAsFilter(history,evalContext);
  }
 else {
    Class clz=search.getFilterClass();
    if (clz == null)     throw new IllegalArgumentException("search must be saved, composition, or must have a class specified");
    log.debug("About to instantiate " + clz);
    PatientFilter pf=null;
    try {
      pf=(PatientFilter)clz.newInstance();
    }
 catch (    Exception ex) {
      log.error("Couldn't instantiate a " + search.getFilterClass(),ex);
      return null;
    }
    Class[] stringSingleton={String.class};
    if (search.getArguments() != null) {
      for (      SearchArgument sa : search.getArguments()) {
        if (log.isDebugEnabled())         log.debug("Looking at (" + sa.getPropertyClass() + ") "+ sa.getName()+ " -> "+ sa.getValue());
        PropertyDescriptor pd=null;
        try {
          pd=new PropertyDescriptor(sa.getName(),clz);
        }
 catch (        IntrospectionException ex) {
          log.error("Error while examining property " + sa.getName(),ex);
          continue;
        }
        Class<?> realPropertyType=pd.getPropertyType();
        String valueAsString=sa.getValue();
        String testForExpression=search.getArgumentValue(sa.getName());
        if (evalContext != null && EvaluationContext.isExpression(testForExpression)) {
          log.debug("found expression: " + testForExpression);
          Object evaluated=evalContext.evaluateExpression(testForExpression);
          if (evaluated != null) {
            if (evaluated instanceof Date)             valueAsString=Context.getDateFormat().format((Date)evaluated);
 else             valueAsString=evaluated.toString();
          }
          log.debug("evaluated to: " + valueAsString);
        }
        Object value=null;
        Class<?> valueClass=sa.getPropertyClass();
        try {
          Method valueOfMethod=null;
          try {
            valueOfMethod=valueClass.getMethod("valueOf",stringSingleton);
          }
 catch (          NoSuchMethodException ex) {
          }
          if (valueOfMethod != null) {
            Object[] holder={valueAsString};
            value=valueOfMethod.invoke(pf,holder);
          }
 else           if (realPropertyType.isEnum()) {
            List<Enum> constants=Arrays.asList((Enum[])realPropertyType.getEnumConstants());
            for (            Enum e : constants) {
              if (e.toString().equals(valueAsString)) {
                value=e;
                break;
              }
            }
          }
 else           if (String.class.equals(valueClass)) {
            value=valueAsString;
          }
 else           if (Location.class.equals(valueClass)) {
            LocationEditor ed=new LocationEditor();
            ed.setAsText(valueAsString);
            value=ed.getValue();
          }
 else           if (Concept.class.equals(valueClass)) {
            ConceptEditor ed=new ConceptEditor();
            ed.setAsText(valueAsString);
            value=ed.getValue();
          }
 else           if (Program.class.equals(valueClass)) {
            ProgramEditor ed=new ProgramEditor();
            ed.setAsText(valueAsString);
            value=ed.getValue();
          }
 else           if (ProgramWorkflowState.class.equals(valueClass)) {
            ProgramWorkflowStateEditor ed=new ProgramWorkflowStateEditor();
            ed.setAsText(valueAsString);
            value=ed.getValue();
          }
 else           if (EncounterType.class.equals(valueClass)) {
            EncounterTypeEditor ed=new EncounterTypeEditor();
            ed.setAsText(valueAsString);
            value=ed.getValue();
          }
 else           if (Form.class.equals(valueClass)) {
            FormEditor ed=new FormEditor();
            ed.setAsText(valueAsString);
            value=ed.getValue();
          }
 else           if (Drug.class.equals(valueClass)) {
            DrugEditor ed=new DrugEditor();
            ed.setAsText(valueAsString);
            value=ed.getValue();
          }
 else           if (PersonAttributeType.class.equals(valueClass)) {
            PersonAttributeTypeEditor ed=new PersonAttributeTypeEditor();
            ed.setAsText(valueAsString);
            value=ed.getValue();
          }
 else           if (Cohort.class.equals(valueClass)) {
            CohortEditor ed=new CohortEditor();
            ed.setAsText(valueAsString);
            value=ed.getValue();
          }
 else           if (Date.class.equals(valueClass)) {
            DateFormat df=Context.getDateFormat();
            CustomDateEditor ed=new CustomDateEditor(df,true,10);
            ed.setAsText(valueAsString);
            value=ed.getValue();
          }
 else {
            value=valueAsString;
          }
        }
 catch (        Exception ex) {
          log.error("error converting \"" + valueAsString + "\" to "+ valueClass,ex);
          continue;
        }
        if (value != null) {
          if (realPropertyType.isAssignableFrom(valueClass)) {
            log.debug("setting value of " + sa.getName() + " to "+ value);
            try {
              pd.getWriteMethod().invoke(pf,value);
            }
 catch (            Exception ex) {
              log.error("Error setting value of " + sa.getName() + " to "+ sa.getValue()+ " -> "+ value,ex);
              continue;
            }
          }
 else           if (Collection.class.isAssignableFrom(realPropertyType)) {
            log.debug(sa.getName() + " is a Collection property");
            try {
              Collection collection=(Collection)pd.getReadMethod().invoke(pf,(Object[])null);
              if (collection == null) {
                if (SortedSet.class.isAssignableFrom(realPropertyType)) {
                  collection=new TreeSet();
                  log.debug("instantiated a TreeSet");
                  pd.getWriteMethod().invoke(pf,collection);
                }
 else                 if (Set.class.isAssignableFrom(realPropertyType)) {
                  collection=new HashSet();
                  log.debug("instantiated a HashSet");
                  pd.getWriteMethod().invoke(pf,collection);
                }
 else {
                  collection=new ArrayList();
                  log.debug("instantiated an ArrayList");
                  pd.getWriteMethod().invoke(pf,collection);
                }
              }
              collection.add(value);
            }
 catch (            Exception ex) {
              log.error("Error instantiating collection for property " + sa.getName() + " whose class is "+ realPropertyType,ex);
              continue;
            }
          }
 else {
            log.error(pf.getClass() + " . " + sa.getName()+ " should be "+ realPropertyType+ " but is given as "+ valueClass);
          }
        }
      }
    }
    log.debug("Returning " + pf);
    return pf;
  }
}
