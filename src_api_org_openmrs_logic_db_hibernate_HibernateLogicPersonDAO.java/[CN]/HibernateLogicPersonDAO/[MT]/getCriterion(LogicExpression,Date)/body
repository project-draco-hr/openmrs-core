{
  Operator operator=logicExpression.getOperator();
  Object rightOperand=logicExpression.getRightOperand();
  Object leftOperand=null;
  if (logicExpression instanceof LogicExpressionBinary) {
    leftOperand=((LogicExpressionBinary)logicExpression).getLeftOperand();
  }
  List<Criterion> criterion=new ArrayList<Criterion>();
  String attr="";
  String token=logicExpression.getRootToken();
  if (token.equalsIgnoreCase("GENDER"))   attr="gender";
 else   if (token.equalsIgnoreCase("BIRTHDATE"))   attr="birthdate";
 else   if (token.equalsIgnoreCase("BIRTHDATE ESTIMATED"))   attr="birthdateEstimated";
 else   if (token.equalsIgnoreCase("DEAD"))   attr="dead";
 else   if (token.equalsIgnoreCase("DEATH DATE"))   attr="deathDate";
 else   if (token.equalsIgnoreCase("CAUSE OF DEATH"))   attr="causeOfDeath";
 else {
    log.error("Illegal or unsupported token:" + token);
  }
  if (operator == Operator.BEFORE || operator == Operator.LT) {
    criterion.add(Restrictions.lt(attr,rightOperand));
  }
 else   if (operator == Operator.AFTER || operator == Operator.GT) {
    criterion.add(Restrictions.gt(attr,rightOperand));
  }
 else   if (operator == Operator.AND || operator == Operator.OR) {
    Criterion leftCriteria=null;
    Criterion rightCriteria=null;
    if (leftOperand instanceof LogicExpression) {
      leftCriteria=this.getCriterion((LogicExpression)leftOperand,indexDate);
    }
    if (rightOperand instanceof LogicExpression) {
      rightCriteria=this.getCriterion((LogicExpression)rightOperand,indexDate);
    }
    if (leftCriteria != null && rightCriteria != null) {
      if (operator == Operator.AND) {
        criterion.add(Restrictions.and(leftCriteria,rightCriteria));
      }
      if (operator == Operator.OR) {
        criterion.add(Restrictions.or(leftCriteria,rightCriteria));
      }
    }
  }
 else   if (operator == Operator.NOT) {
    Criterion rightCriteria=null;
    if (rightOperand instanceof LogicExpression) {
      rightCriteria=this.getCriterion((LogicExpression)rightOperand,indexDate);
    }
    if (rightCriteria != null) {
      criterion.add(Restrictions.not(rightCriteria));
    }
  }
 else   if (operator == Operator.CONTAINS || operator == Operator.EQUALS) {
    criterion.add(Restrictions.eq(attr,rightOperand));
  }
 else   if (operator == Operator.LTE) {
    criterion.add(Restrictions.le(attr,rightOperand));
  }
 else   if (operator == Operator.GTE) {
    criterion.add(Restrictions.ge(attr,rightOperand));
  }
 else   if (operator == Operator.EXISTS) {
  }
 else   if (operator == Operator.ASOF && rightOperand instanceof Date) {
    indexDate=(Date)rightOperand;
    criterion.add(Restrictions.le(attr,indexDate));
  }
 else   if (operator == Operator.WITHIN && rightOperand instanceof Duration) {
    Duration duration=(Duration)rightOperand;
    Calendar within=Calendar.getInstance();
    within.setTime(indexDate);
    if (duration.getUnits() == Duration.Units.YEARS) {
      within.add(Calendar.YEAR,duration.getDuration().intValue());
    }
 else     if (duration.getUnits() == Duration.Units.MONTHS) {
      within.add(Calendar.MONTH,duration.getDuration().intValue());
    }
 else     if (duration.getUnits() == Duration.Units.WEEKS) {
      within.add(Calendar.WEEK_OF_YEAR,duration.getDuration().intValue());
    }
 else     if (duration.getUnits() == Duration.Units.DAYS) {
      within.add(Calendar.DAY_OF_YEAR,duration.getDuration().intValue());
    }
 else     if (duration.getUnits() == Duration.Units.MINUTES) {
      within.add(Calendar.MINUTE,duration.getDuration().intValue());
    }
 else     if (duration.getUnits() == Duration.Units.SECONDS) {
      within.add(Calendar.SECOND,duration.getDuration().intValue());
    }
    if (indexDate.compareTo(within.getTime()) > 0) {
      criterion.add(Restrictions.between(attr,within.getTime(),indexDate));
    }
 else {
      criterion.add(Restrictions.between(attr,indexDate,within.getTime()));
    }
  }
  Criterion c=null;
  for (  Criterion crit : criterion) {
    if (c == null) {
      c=crit;
    }
 else {
      c=Restrictions.and(c,crit);
    }
  }
  return c;
}
