{
  records=null;
  Locale locale=Context.getLocale();
  if (name.equals("patientIdentifierType")) {
    PatientService ps=Context.getPatientService();
    records=ps.getPatientIdentifierTypes().iterator();
  }
 else   if (name.equals("relationshipType")) {
    PersonService ps=Context.getPersonService();
    records=ps.getRelationshipTypes().iterator();
  }
 else   if (name.equals("location")) {
    EncounterService es=Context.getEncounterService();
    records=es.getLocations().iterator();
  }
 else   if (name.equals("tribe")) {
    PatientService ps=Context.getPatientService();
    records=ps.getTribes().iterator();
  }
 else   if (name.equals("cohort")) {
    List<Cohort> cohorts=Context.getCohortService().getCohorts();
    records=cohorts.iterator();
  }
 else   if (name.equals("reportObject")) {
    List ret=null;
    if (reportObjectType != null)     ret=Context.getReportService().getReportObjectsByType(reportObjectType);
 else     ret=Context.getReportService().getAllReportObjects();
    records=ret.iterator();
  }
 else   if (name.equals("civilStatus")) {
    ConceptService cs=Context.getConceptService();
    Concept civilStatus=cs.getConcept(OpenmrsConstants.CIVIL_STATUS_CONCEPT_ID);
    if (civilStatus == null)     log.error("OpenmrsConstants.CIVIL_STATUS_CONCEPT_ID is defined incorrectly.");
    records=civilStatus.getAnswers().iterator();
    Map<String,String> opts=new HashMap<String,String>();
    for (    ConceptAnswer a : civilStatus.getAnswers()) {
      opts.put(a.getAnswerConcept().getConceptId().toString(),a.getAnswerConcept().getName(locale,false).getName());
    }
    records=opts.entrySet().iterator();
    if (select != null)     select=select.toString() + "=" + opts.get(select);
  }
 else   if (name.equals("gender")) {
    Map<String,String> opts=OpenmrsConstants.GENDER();
    records=opts.entrySet().iterator();
    if (select != null)     select=select.toString() + "=" + opts.get(select);
  }
 else {
    log.error(name + " not found in ForEachRecord list");
  }
  if (records == null || records.hasNext() == false) {
    records=null;
    return SKIP_BODY;
  }
 else   return EVAL_BODY_BUFFERED;
}
