{
  records=null;
  Locale locale=Context.getLocale();
  if (name.equals("patientIdentifierType")) {
    PatientService ps=Context.getPatientService();
    records=ps.getAllPatientIdentifierTypes().iterator();
  }
 else   if (name.equals("relationshipType")) {
    PersonService ps=Context.getPersonService();
    records=ps.getAllRelationshipTypes().iterator();
  }
 else   if (name.equals("encounterType")) {
    EncounterService es=Context.getEncounterService();
    records=es.getAllEncounterTypes().iterator();
  }
 else   if (name.equals("location")) {
    LocationService locServ=Context.getLocationService();
    records=locServ.getAllLocations().iterator();
  }
 else   if (name.equals("cohort")) {
    List<Cohort> cohorts=Context.getCohortService().getAllCohorts();
    records=cohorts.iterator();
  }
 else   if (name.equals("conceptSource")) {
    List<ConceptSource> conceptSources=Context.getConceptService().getAllConceptSources();
    records=conceptSources.iterator();
  }
 else   if (name.equals("form")) {
    List<Form> forms=Context.getFormService().getAllForms();
    records=forms.iterator();
  }
 else   if (name.equals("reportSchemaXml")) {
    List<ReportSchemaXml> list=Context.getReportService().getReportSchemaXmls();
    records=list.iterator();
  }
 else   if (name.equals("reportObject")) {
    List<AbstractReportObject> ret=null;
    if (reportObjectType != null)     ret=Context.getReportObjectService().getReportObjectsByType(reportObjectType);
 else     ret=Context.getReportObjectService().getAllReportObjects();
    records=ret.iterator();
  }
 else   if (name.equals("civilStatus")) {
    ConceptService cs=Context.getConceptService();
    Concept civilStatus=cs.getConcept(OpenmrsConstants.CIVIL_STATUS_CONCEPT_ID);
    if (civilStatus == null)     log.error("OpenmrsConstants.CIVIL_STATUS_CONCEPT_ID is defined incorrectly.");
    records=civilStatus.getAnswers().iterator();
    Map<String,String> opts=new HashMap<String,String>();
    for (    ConceptAnswer a : civilStatus.getAnswers()) {
      opts.put(a.getAnswerConcept().getConceptId().toString(),a.getAnswerConcept().getBestName(locale).getName());
    }
    records=opts.entrySet().iterator();
    if (select != null)     select=select.toString() + "=" + opts.get(select);
  }
 else   if (name.equals("gender")) {
    Map<String,String> opts=OpenmrsConstants.GENDER();
    records=opts.entrySet().iterator();
    if (select != null)     select=select.toString() + "=" + opts.get(select);
  }
 else   if (name.equals("workflowStatus")) {
    List<ProgramWorkflowState> ret=Context.getProgramWorkflowService().getStates();
    records=ret.iterator();
  }
 else   if (name.equals("workflowProgram")) {
    List<org.openmrs.Program> ret=Context.getProgramWorkflowService().getAllPrograms();
    records=ret.iterator();
  }
 else   if (name.equals("role")) {
    List<Role> ret=Context.getUserService().getAllRoles();
    records=ret.iterator();
  }
 else   if (name.equals("conceptSet")) {
    if (conceptSet == null)     throw new IllegalArgumentException("Must specify conceptSet");
    Concept c=OpenmrsUtil.getConceptByIdOrName(conceptSet);
    if (c == null)     throw new IllegalArgumentException("Can't find conceptSet " + conceptSet);
    List<Concept> list=Context.getConceptService().getConceptsByConceptSet(c);
    records=list.iterator();
  }
 else   if (name.equals("answer")) {
    if (concept == null)     throw new IllegalArgumentException("Must specify concept");
    Concept c=OpenmrsUtil.getConceptByIdOrName(concept);
    if (c == null)     throw new IllegalArgumentException("Can't find concept " + concept);
    if (c.getAnswers() != null)     records=c.getAnswers().iterator();
 else     records=new ArrayList<Concept>().iterator();
  }
 else {
    try {
      Class<?> cls=Context.loadClass(name);
      Constructor<?> ct=cls.getConstructor();
      Iterable<?> iterable=(Iterable<?>)ct.newInstance();
      records=iterable.iterator();
    }
 catch (    Exception e) {
      log.error(name + " not found in ForEachRecord list " + e);
    }
  }
  if (records == null || records.hasNext() == false) {
    records=null;
    return SKIP_BODY;
  }
 else   return EVAL_BODY_BUFFERED;
}
