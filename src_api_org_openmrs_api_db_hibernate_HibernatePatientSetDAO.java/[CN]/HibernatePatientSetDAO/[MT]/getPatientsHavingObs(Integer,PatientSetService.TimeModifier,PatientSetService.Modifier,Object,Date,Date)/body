{
  if (conceptId == null && value == null)   throw new IllegalArgumentException("Can't have conceptId == null and value == null");
  if (conceptId == null && (timeModifier != TimeModifier.ANY && timeModifier != TimeModifier.NO))   throw new IllegalArgumentException("If conceptId == null, timeModifier must be ANY or NO");
  if (conceptId == null && modifier != Modifier.EQUAL) {
    throw new IllegalArgumentException("If conceptId == null, modifier must be EQUAL");
  }
  Concept concept=null;
  if (conceptId != null)   concept=Context.getConceptService().getConcept(conceptId);
  Number numericValue=null;
  String stringValue=null;
  Concept codedValue=null;
  String valueSql=null;
  if (value != null) {
    if (concept == null) {
      if (value instanceof Concept)       codedValue=(Concept)value;
 else       codedValue=Context.getConceptService().getConceptByName(value.toString());
      valueSql="o.value_coded";
    }
 else     if (concept.getDatatype().getHl7Abbreviation().equals("NM")) {
      if (value instanceof Number)       numericValue=(Number)value;
 else       numericValue=new Double(value.toString());
      valueSql="o.value_numeric";
    }
 else     if (concept.getDatatype().getHl7Abbreviation().equals("ST")) {
      stringValue=value.toString();
      valueSql="o.value_text";
      if (modifier == null)       modifier=Modifier.EQUAL;
    }
 else     if (concept.getDatatype().getHl7Abbreviation().equals("CWE")) {
      if (value instanceof Concept)       codedValue=(Concept)value;
 else       codedValue=Context.getConceptService().getConceptByName(value.toString());
      valueSql="o.value_coded";
    }
  }
  StringBuilder sb=new StringBuilder();
  boolean useValue=value != null;
  boolean doSqlAggregation=timeModifier == TimeModifier.MIN || timeModifier == TimeModifier.MAX || timeModifier == TimeModifier.AVG;
  boolean doInvert=false;
  String dateSql="";
  String dateSqlForSubquery="";
  if (fromDate != null) {
    dateSql+=" and o.obs_datetime >= :fromDate ";
    dateSqlForSubquery+=" and obs_datetime >= :fromDate ";
  }
  if (toDate != null) {
    dateSql+=" and o.obs_datetime <= :toDate ";
    dateSqlForSubquery+=" and obs_datetime <= :toDate ";
  }
  if (timeModifier == TimeModifier.ANY || timeModifier == TimeModifier.NO) {
    if (timeModifier == TimeModifier.NO)     doInvert=true;
    sb.append("select o.person_id from obs o ");
    if (conceptId != null)     sb.append("where concept_id = :concept_id ");
    sb.append(dateSql);
  }
 else   if (timeModifier == TimeModifier.FIRST || timeModifier == TimeModifier.LAST) {
    boolean isFirst=timeModifier == PatientSetService.TimeModifier.FIRST;
    sb.append("select o.person_id " + "from obs o inner join (" + "    select person_id, " + (isFirst ? "min" : "max") + "(obs_datetime) as obs_datetime"+ "    from obs"+ "    where concept_id = :concept_id "+ dateSqlForSubquery+ "    group by person_id"+ ") subq on o.person_id = subq.person_id and o.obs_datetime = subq.obs_datetime "+ "where o.concept_id = :concept_id ");
  }
 else   if (doSqlAggregation) {
    String sqlAggregator=timeModifier.toString();
    valueSql=sqlAggregator + "(" + valueSql+ ")";
    sb.append("select o.person_id " + "from obs o where concept_id = :concept_id " + dateSql + "group by o.person_id ");
  }
 else {
    throw new IllegalArgumentException("TimeModifier '" + timeModifier + "' not recognized");
  }
  if (useValue) {
    sb.append(doSqlAggregation ? " having " : (conceptId == null ? " where " : " and "));
    sb.append(valueSql + " ");
    sb.append(modifier.getSqlRepresentation() + " :value");
  }
  if (!doSqlAggregation)   sb.append(" group by o.person_id ");
  log.debug("query: " + sb);
  Query query=sessionFactory.getCurrentSession().createSQLQuery(sb.toString());
  query.setCacheMode(CacheMode.IGNORE);
  if (conceptId != null)   query.setInteger("concept_id",conceptId);
  if (useValue) {
    if (numericValue != null)     query.setDouble("value",numericValue.doubleValue());
 else     if (codedValue != null)     query.setInteger("value",codedValue.getConceptId());
 else     if (stringValue != null)     query.setString("value",stringValue);
 else     throw new IllegalArgumentException("useValue is true, but numeric, coded, and string values are all null");
  }
  if (fromDate != null)   query.setDate("fromDate",fromDate);
  if (toDate != null)   query.setDate("toDate",fromDate);
  PatientSet ret;
  if (doInvert) {
    ret=getAllPatients();
    ret.removeAllIds(query.list());
  }
 else {
    ret=new PatientSet();
    List patientIds=query.list();
    ret.setPatientIds(new ArrayList<Integer>(patientIds));
  }
  return ret;
}
